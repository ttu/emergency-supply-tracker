# AI Context Limiting Hooks

Scripts to reduce Claude Code context usage and improve efficiency.

## Best Practices

1. **Start Claude Code from repo root** so `$CLAUDE_PROJECT_DIR` works cleanly in hooks
2. **Keep project rules in generated files** (`AI_CONTEXT.md`) rather than repeating in chat
3. **Reference files instead of pasting**: "Fix the failures in TEST_FAILURES.md"
4. **Use `/handoff` command** before ending a session to create `HANDOFF.md` for context continuity

## Generated Files

| File               | Purpose                          | Generated By                          |
| ------------------ | -------------------------------- | ------------------------------------- |
| `AI_CONTEXT.md`    | Repo summary, scripts, structure | `make_ai_context.sh` (session start)  |
| `TEST_FAILURES.md` | Parsed test failures             | `test_output.sh` (after failed tests) |
| `DECISIONS.md`     | Session state before compaction  | `make_decisions.sh` (pre-compact)     |
| `HANDOFF.md`       | Session context for continuity   | `/handoff` command (manual)           |

All generated files are in `.gitignore`.

## Hook Configuration

Hooks are configured in `.claude/settings.json` (version controlled).

| Event            | Matcher | Script                   | Purpose                      |
| ---------------- | ------- | ------------------------ | ---------------------------- |
| SessionStart     | (all)   | `make_ai_context.sh`     | Generate repo summary        |
| UserPromptSubmit | (all)   | `prompt_prefix.sh`       | Prepend context instructions |
| PreToolUse       | Read    | `block_unwanted_dirs.sh` | Block wasteful directories   |
| PreToolUse       | Read    | `block_big_reads.sh`     | Block large/binary files     |
| PreToolUse       | Glob    | `block_unwanted_dirs.sh` | Block wasteful directories   |
| PreToolUse       | Grep    | `block_unwanted_dirs.sh` | Block wasteful directories   |
| PostToolUse      | Bash    | `test_output.sh`         | Parse test failures          |
| PreCompact       | (all)   | `make_decisions.sh`      | Generate session state       |

## Scripts

### `make_ai_context.sh`

**Event:** SessionStart

Generates `AI_CONTEXT.md` with repo summary, scripts, structure.

### `prompt_prefix.sh`

**Event:** UserPromptSubmit

Auto-prepends: "Read AI_CONTEXT.md and TEST_FAILURES.md first, avoid node_modules/coverage/lockfiles."

### `block_unwanted_dirs.sh`

**Event:** PreToolUse (Read, Glob, Grep)

Blocks: node_modules, .git, dist, build, coverage, .next, .nuxt, .cache, .turbo, .vite, storybook-static, \_\_pycache\_\_, venv, vendor

### `block_big_reads.sh`

**Event:** PreToolUse (Read)

Blocks:

- Files > 2000 lines or > 100KB
- Binary files (.png, .jpg, .woff, etc.)
- Minified files (.min.js, .min.css)
- Lock files (package-lock.json, yarn.lock, etc.)

### `make_decisions.sh`

**Event:** PreCompact

Generates `DECISIONS.md` with current session state before context compaction:

- Current branch and uncommitted changes
- Modified files (git status)
- Changes summary (git diff --stat)
- Branch commits (if not on main)
- Recently modified files (last 60 minutes)

### `test_output.sh`

**Event:** PostToolUse (Bash)

Parses Vitest/Jest/Playwright output and generates `TEST_FAILURES.md` on failures.

**Note:** For Playwright tests, pipe the output to ensure the hook receives it:

```bash
npx playwright test ... 2>&1 | cat
```

## Manual Usage

```bash
# Generate context (also runs on session start)
./scripts/ai/make_ai_context.sh

# Generate session state (also runs before compaction)
./scripts/ai/make_decisions.sh

# Parse test failures manually
npm test 2>&1 | ./scripts/ai/test_output.sh

# Create handoff document for session continuity
/handoff
```

## Customization

### Blocked directories

Edit `BLOCKED_DIRS` array in `block_unwanted_dirs.sh`

### File size limits

```bash
MAX_LINES=1000 MAX_SIZE_KB=50 bash scripts/ai/block_big_reads.sh
```

## Claude Code Hook API Reference

Official documentation: [Claude Code hooks](https://code.claude.com/docs/en/hooks)

When writing hooks for Claude Code, use these JSON field names:

### Input Fields (received by hooks)

- `hook_event_name` - The hook event type (e.g., "PreToolUse", "PostToolUse")
- `tool_name` - The tool being used (e.g., "Read", "Bash")
- `tool_input` - The tool's input parameters
  - `file_path` / `path` - File path for Read/Glob/Grep
  - `pattern` - Pattern for Glob/Grep
  - `command` - Command for Bash
- `tool_response` - The tool's output (PostToolUse only)
  - `stdout` - Standard output
  - `stderr` - Standard error

### Output Fields (returned by hooks)

**PreToolUse hooks** - to block an operation:

```json
{
  "decision": "block",
  "message": "Reason for blocking"
}
```

**UserPromptSubmit hooks** - three options:

1. **Plain text** (simpler) - stdout is added as context:

```text
Instructions to prepend to the prompt.
```

2. **JSON with additionalContext**:

```json
{
  "hookSpecificOutput": {
    "additionalContext": "Instructions to prepend"
  }
}
```

3. **To block a prompt**:

```json
{
  "decision": "block",
  "reason": "Why the prompt was blocked"
}
```

**PostToolUse/PreCompact hooks** - no response required, just perform actions.
